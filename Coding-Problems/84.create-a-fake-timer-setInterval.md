# 84. create a fake timer (setInterval)

### Problem

https://bigfrontend.dev/problem/create-a-fake-timer-setInterval

#

### Problem Description

This is a follow-up on [36. create a fake timer(setTimeout)](https://bigfrontend.dev/problem/create-a-fake-timer)

Like `setTimeout`, `setInterval` also is not accurate. (please refer [Event Loop](https://javascript.info/event-loop) for detail).

This is OK in general web application, but might be problematic in test.

Could you implement your own `setInterval()` and `clearInterval()` to be sync? so that they have **accurate timing** for test. This is what [FakeTimes](https://github.com/sinonjs/fake-timers) are for.

By "accurate", it means **suppose all functions cost no time**, we start our function at time `0`, then `setInterval(func1, 100)` would schedule `func1` exactly at `100, 200, 300 .etc`.

You need to replace `Date.now()` as well to provide the time.

```js
class FakeTimer {
  install() {
    // replace window.setInterval, window.clearInterval, Date.now
    // with your implementation
  }

  uninstall() {
    // restore the original implementation of
    // window.setInterval, window.clearInterval, Date.now
  }

  tick() {
    // run the scheduled functions without waiting
  }
}
```

** Be careful about the infinite loops **. Your code is tested like this:

```js
const fakeTimer = new FakeTimer();
fakeTimer.install();

const logs = [];
const log = () => {
  logs.push(Date.now());
};

let count = 0;
const id = setInterval(() => {
  if (count > 1) {
    clearInterval(id);
  } else {
    log();
  }
  count += 1;
}, 100);
// log 'A' at every 100, stop at 200
fakeTimer.tick();
fakeTimer.uninstall();

expect(logs).toEqual([100, 200]);
```

**Note**

Only `Date.now()` is used when judging your code, you can ignore other time related apis.

#

### Understanding the problem

I am asked to write a "synchronous" version of `setInterval()` and its corresponding `clearInterval()`. I also need to write my own version of `Date.now()` to provide the current time, which is the total amount of time that a scheduled function has been 'waited' before it executes. For instance, the following code snippet should logs `100, 200`.

```js
setInterval(() => {
  console.log(Date.now);
}, 100);
```

I should implement this as a `FakeTimer` class which is going to have three methods: `install()`, `uninstall()` and `tick()`. The `install()` method is going to replace the original `setInterval()`, `clearInterval()` and `Date.now()` with my implementation. The `uninstall()` method is going to restore the original implementation. The `tick()` method is going to run the scheduled functions without waiting, which means two things, one the scheduled functions don't need to actually wait the specified amount of time before they execute, two there might be multiple functions get scheduled. To trigger the interval timer, the `tick()` method needs to be called manually by the user.

#

### Approach

In the constructor of the `FakeTimer` class, I am going to first store all the original implementation. Then initialize a property called `taskQueue` to be an empty array that is going to store the scheduled functions. I am also going to initialize a property named `currTime` that is going to keep track of the 'current' time; initially set it to `0`.

In the `install()` method, I am going to define my implementation of these three functions and set `window.setInterval()`, `window.clearInterval` and `Date.now` to my implementation.

My implementation of `setInterval()` is going to take in a callback function and delay, and is going to return the id of the interval timer so that it can be cancelled with `clearInterval()`. I am going to append the callback into `this.taskQueue` alongside with the delay and the total amount of time it should wait which is initially equal to the delay plus `currTime`, because I need to handle nested interval timer. In addition, I also need to generate an id for the callback function and also store the id alongside with the callback function. The id is going to be equal to the index of the callback function in the `taskQueue` array and that would be the id of the interval timer.

To clear an interval timer by id, in my `clearInterval()` I am going to delete all the callback functions with that `id` in the `taskQueue` array.

My version of `Date.now()` is going to just return the `currTime`.

In the `uninstall()` method, I am going to set `window.setInterval()`, `window.clearInterval` and `Date.now` to the original implementation that I have stored.

In the `tick()`, first I am going to pop the oldest task off the `taskQueue` array and set `currTime` to the total amount of time that the task has been wait. Then I would execute the task, add its delay to the total amount of waiting time, and push the task back to the `taskQueue` with its delay, the total amount of waiting time and its id. While the `taskQueue` array is not empty, continue this process.

### Solution

```js
class FakeTimer {
  constructor() {
    this.origSetInterval = window.setInterval;
    this.origClearInterval = window.clearInterval;
    this.origDateNow = Date.now;

    this.taskQueue = [];
    this.currTime = 0;
    this.deletedTaskIds = new Set();
  }

  install() {
    window.setInterval = (callback, delay) => {
      const totalWaitingTime = this.currTime + delay;
      const id = this.taskQueue.length;

      this.taskQueue.push({
        id,
        totalWaitingTime,
        delay,
        callback,
      });

      return id;
    };

    window.clearInterval = (id) => {
      this.taskQueue = this.taskQueue.filter((task) => task.id !== id);
      this.deletedTaskIds.add(id);
    };

    Date.now = () => this.currTime;
  }

  uninstall() {
    window.setInterval = this.origSetInterval;
    window.clearInterval = this.origClearInterval;
    Date.now = this.origDateNow;
  }

  tick() {
    while (this.taskQueue.length > 0) {
      const task = this.taskQueue.shift();
      if (this.deletedTaskIds.has(task.id)) {
        continue;
      }

      this.currTime = task.totalWaitingTime;
      task.callback();
      this.taskQueue.push({
        ...task,
        totalWaitingTime: task.delay + task.totalWaitingTime,
      });
    }
  }
}
```
