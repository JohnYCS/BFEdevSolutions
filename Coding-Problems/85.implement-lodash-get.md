# 85. implement `_.get()`

### Problem

https://bigfrontend.dev/problem/implement-lodash-get

#

### Problem Description

[\_.get(object, path, [defaultValue])](https://lodash.com/docs/4.17.15#get) is a handy method to help retrieving data from an arbitrary object. if the resolved value from `path` is `undefined`, `defaultValue` is returned.

Can you create your own `get()`?

```js
const obj = {
  a: {
    b: {
      c: [1, 2, 3],
    },
  },
};

get(obj, 'a.b.c'); // [1,2,3]
get(obj, 'a.b.c.0'); // 1
get(obj, 'a.b.c[1]'); // 2
get(obj, ['a', 'b', 'c', '2']); // 3
get(obj, 'a.b.c[3]'); // undefined
get(obj, 'a.c', 'bfe'); // 'bfe'
```

#

### Understanding the problem

I am asked to write a function called `get` that will take in an source object, a `path` parameter which is either a string or an array of strings, and optionally a `defaultValue` parameter, which defaults to `undefined`. The function `get()` is going to retrieve the value at the specified path of the provided object.

#

### Approach

I could solve this problem either iteratively or recursively. In both approach, I would traverse the source object using the path and initialize a pointer that is going to keep track of the property name I am currently at in the path.

For both approach, first I am going to check if the `path` is a string, if it is, then split the string into an array with `'.'` or `'['` or `']'` as separator.

To solve this problem recursively, I would define a function that would be my actual recursive function. It will take in a current head, which is initially to be equal to the source object, the path array, a pointer, which initially is going to be equal to 0, and also the `defaultValue`. I will call the recursive function on each property in the path array, recursively traversing the source object, until either the property doesn't exist in the source object or I eventually reach the very end of the path array. In the recursive function, I am going to check if the index is equal to the length of the path array, if it is, either return the current head, which is passed to the recursive function in the previous step, or the `defaultValue` if the current head is undefined; then I am going to make sure that the current head is not `undefined`, if it is `undefined`, return the `defaultValue`; these are both of my base cases in the recursive function. Then I will get the current property name that is what the pointer currently points at in the path array, update the current head to the value of the current property, increase the pointer by one, so make the pointer point to the next property name, and call the recursive function passing in the updated current head, the path array, the updated pointer and the `defaultValue`.

To solve this problem iteratively, I would initialize a variable that is going to keep track of the current head; initially, set it to the source object. I will also initialize a pointer to 0. While the current value is not `undefined`, meaning the previous property is a key in the source object, and the pointer is less than the length of the path array, meaning I still have properties to look through, get the property which the current pointer points at in the path array, get the value of that property in the current head and update the current head to that value. Once I get out the while loop, return the current head or the `defaultValue` if the current head is `undefined`.

üôã‚Äç‚ôÄÔ∏èüôã‚Äç‚ôÇÔ∏è In both approach, I didn't handle the case in which `path` is an empty array.

### Recursive Solution

```js
/**
 * @param {object} source
 * @param {string | string[]} path
 * @param {any} [defaultValue]
 * @return {any}
 */
function get(source, path, defaultValue = undefined) {
  path = Array.isArray(path) ? path : path.split(/\.|\[|\]/);

  if (path[path.length - 1] === '') path.pop();

  return getImpl(source, path, 0, defaultValue);
}

function getImpl(currentHead, path, idx, defaultValue) {
  if (path.length === 0 || currentHead === undefined) {
    return defaultValue;
  }

  if (idx === path.length) return currentHead || defaultValue;

  const property = path[idx];
  return getImpl(currentHead[property], path, idx + 1, defaultValue);
}
```

### Iterative Solution

```js
/**
 * @param {object} source
 * @param {string | string[]} path
 * @param {any} [defaultValue]
 * @return {any}
 */
function get(source, path, defaultValue = undefined) {
  path = Array.isArray(path) ? path : path.split(/\.|\[|\]/);

  if (path[path.length - 1] === '') path.pop();

  if (path.length === 0) return defaultValue;

  let currentHead = source;
  let idx = 0;

  while (currentHead && idx < path.length) {
    const property = path[idx];
    currentHead = currentHead[property];
    idx++;
  }

  return currentHead || defaultValue;
}
```

### Iterative Solution with Reduce

```js
/**
 * @param {object} source
 * @param {string | string[]} path
 * @param {any} [defaultValue]
 * @return {any}
 */
function get(source, path, defaultValue = undefined) {
  path = Array.isArray(path) ? path : path.split(/\.|\[|\]/);

  if (path[path.length - 1] === '') path.pop();

  if (path.length === 0) return defaultValue;

  const value = path.reduce(
    (currentHead, property) => currentHead[property],
    source
  );
  return value || defaultValue;
}
```
