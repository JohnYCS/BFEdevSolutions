# 82. find available meeting slots

### Problem

https://bigfrontend.dev/problem/find-available-meeting-slots

#

### Problem Description

`[start, end]` is a time interval, with all integers from 0 to 24.

Given schedules for all team members,

<!--prettier-ignore-->
```js
[
  [[13,15], [11,12], [10,13]], //schedule for member 1
  [[8, 9]], // schedule for member 2
  [[13, 18]] // schedule for member 3
]
```

You need to create a function `findMeetingSlots()` to return the time slots available for all the members to have a meeting.

For the input above, below slots should be returned

<!--prettier-ignore-->
```js
[[0,8],[9,10],[18,24]]
```

**Notes**

1. the input schedule intervals might be unsorted
2. one member's schedule might have overlapping intervals.

#

### Understanding the problem

I am given an array of schedules for team members. Each schedule is an array of time blocks, which are in the form of `[start, end]`, and both `start` and `end` are integers from 0 to 24. I am asked to write a function that is going to return an array of all the time blocks during which all the team members can have a meeting. The schedules might not be sorted by the start time and they might have overlapping time blocks.

#

### Approach

To solve the problem I would first merge the schedules for the team members into one array and sorted the array by start time in ascending order, so that I can find the time blocks available for all team members. Then I would initialize an empty array that is going to store the available time blocks and a variable called `currentEndTime` that is going to keep track of the current end time to handle the overlapping time blocks; initially, set it to `0`. I will loop through the sorted array of time blocks. At each time block, I am going to compare its start time to the `currentEndTime`, if it is greater than the `currentEndTime`, then it means I have found a available time block, where the start time is `currentEndTime` and the end time is the start time of the current time block; otherwise, compare the `currentEndTime` to the end time of the current time block, if it is smaller than the end time, update `currentEndTime` to the end time of the current time block. When I get out of the loop, compare the `currentEndTime` to `24`, if it is smaller than `24`, push the time block that starts at `currentEndTime` and ends at ``24` to the array of available time blocks. Finally, return the array of available time blocks.

### Solution

```js
// type Interval = [number, number]

/**
 * @param {Interval[][]} schedules
 * @return {Interval[]}
 */
function findMeetingSlots(schedules) {
  const mergedSchedules = mergeSchedules(schedules);
  mergedSchedules.sort((a, b) => a[0] - b[0]);

  const availableTimeBlocks = [];
  let currentEndTime = 0;

  for (const timeBlock of mergedSchedules) {
    const [startTime, endTime] = timeBlock;

    if (startTime > currentEndTime) {
      availableTimeBlocks.push([currentEndTime, startTime]);
    }

    if (endTime > currentEndTime) {
      currentEndTime = endTime;
    }
  }

  if (currentEndTime < 24) {
    availableTimeBlocks.push([currentEndTime, 24]);
  }

  return availableTimeBlocks;
}

function mergeSchedules(schedules) {
  const mergedSchedules = [];
  for (const schedule of schedules) {
    mergedSchedules.push(...schedule);
  }
  return mergedSchedules;
}
```
